/*     File: ackerman_auto.c    Author: R. Bettati            Department of Computer Science            Texas A&M University    Date  : 08/02/09    Modified: 2018-01-27    This file implements the function "ackerman(n,m)", which is used     by the "memtest" program in MP1. Instead of using interactive    prompts, it uses the parameters passed to it by the caller and    returns a struct containing the results and timing information.*//*--------------------------------------------------------------------------*//* DEFINES *//*--------------------------------------------------------------------------*/    /* -- (none) -- */    /*--------------------------------------------------------------------------*//* INCLUDES *//*--------------------------------------------------------------------------*/#include<stdlib.h>#include<stdio.h>#include<string.h>#include<sys/time.h>#include<assert.h>#include "my_allocator.h"#include "ackerman.h"/*--------------------------------------------------------------------------*//* DATA STRUCTURES */ /*--------------------------------------------------------------------------*/    /* -- (none) -- *//*--------------------------------------------------------------------------*//* CONSTANTS *//*--------------------------------------------------------------------------*/    /* -- (none) -- *//*--------------------------------------------------------------------------*//* FORWARDS *//*--------------------------------------------------------------------------*/unsigned long int ackerman(int a, int b);/* used in "ackerman_auto" *//*--------------------------------------------------------------------------*//* LOCAL VARIABLES *//*--------------------------------------------------------------------------*/unsigned long int num_allocations_aa;/*--------------------------------------------------------------------------*//* EXPORTED FUNCTIONS *//*--------------------------------------------------------------------------*/Ackerman_Results ackerman_auto(unsigned int n, unsigned int m) {    /* "n" and "m" are passed to the invoked ackerman function.       Before and after the invocation of the ackerman function, the        value of the wallclock is taken, and the elapsed time for the computation       of the ackerman function is output.    */    struct timeval tp_start; /* Used to compute elapsed time. */    struct timeval tp_end;    Ackerman_Results ret;    ret.n = n; ret.m = m;    assert(gettimeofday(&tp_start, 0) == 0);    ret.result = ackerman(n, m);    assert(gettimeofday(&tp_end, 0) == 0);    ret.num_allocations = num_allocations_aa;    long sec = tp_end.tv_sec - tp_start.tv_sec;    long usec = tp_end.tv_usec - tp_start.tv_usec;    ret.usec = usec + sec*1000000;    return ret;}void print_ackerman_results(Ackerman_Results results) {    printf("Result of ackerman(%d, %d): %d\n", results.n, results.m, results.result);    printf("Time taken for computation: [sec = %ld, musec = %ld]\n", results.usec/1000000, results.usec % 1000000);    printf("Number of allocate/free cycles: %lu\n", results.num_allocations); }/*--------------------------------------------------------------------------*//* LOCAL FUNCTIONS *//*--------------------------------------------------------------------------*/unsigned long int ackerman(int a, int b) {/* This is the implementation of the Ackerman function. The function itself is very   function is very simple (just two recursive calls). We use it to exercise the   memory allocator (see "my_alloc" and "my_free").    For this, there are additional calls to "gettimeofday" to measure the elapsed   time. */  void * mem;  /* The size "to_alloc" of the region to allocate is computed randomly: */  int to_alloc = ((2 << (rand() % 19)) * (rand() % 100)) / 100;  if  (to_alloc < 4) to_alloc = 4;  int result = 0, i;  char c;  mem = my_malloc(to_alloc * sizeof(char));  num_allocations_aa++;  if (mem != NULL) {    // generate a random byte to fulfill the allocated block of memory    c = rand() % 128;    memset(mem, c, to_alloc * sizeof(char));    if (a == 0)      result = b + 1;    else if (b == 0)      result = ackerman(a - 1, 1);    else      result = ackerman(a - 1, ackerman(a, b - 1) );    // check memory value before deleting    for (i = 0; i < to_alloc; i++) {        if (((char*)mem)[i] != c) {            fprintf(stdout, "Memory checking error! Char %i / %i\n", i, to_alloc);//             exit(EXIT_FAILURE);            break;        }    }    my_free(mem);  } else {      fprintf(stderr, "Not enough memory!\n");      exit(EXIT_FAILURE);  }  return result;}